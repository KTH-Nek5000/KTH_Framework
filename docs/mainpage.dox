/**
@brief Documentation file to be used in Doxygen pages.
@author Adam Peplinski
@file

@mainpage Framework for toolboxes developed for Nek5000

@section intro Introduction
This framework provides platform for development and shearing the tools based on [Nek5000] 
(https://nek5000.mcs.anl.gov/) code. It contains number of utilities that allow Nek5000 users to perform 
additional tasks. The main objective is to allow different users to exchange their code that is not 
part of Nek5000 core but operates through standard user interface (mainly through \a userchk). 

@section structure Framework structure
To make this platform easy to expand and reuse existing code we introduce specific directory structure
representing different tasks. All files are grouped by taks and placed in a tree structure, where 
the parent directories (modules in Doxygen nomenclature) perform some operations and can define tasks 
and interfaces that have to be provided by their subdirectories (submodules). This structure can be repeated 
recursively with submodules becoming parent modules for next level structures. A backbone of the whole framework
is module called [frame] (@ref frame) that provides dynamical databases for all tools (modules), runtimes parameters
and timers introduced by framework. This module should be started first and all the remaining tools should 
be registered with it. For more information check [Toolbox page] (@ref toolbox).

@section download Download 
The top level direcotries in the framework point to stable release of three main github repositories (using 
[git submodules] (https://git-scm.com/book/en/v2/Git-Tools-Submodules)): 
- [Nek5000] (https://github.com/Nek5000/Nek5000),
- [toolbox] (https://github.com/adampep/KTH_Toolbox),
- [tool examples] (https://github.com/adampep/KTH_Examples).

Each ot these repositories can be downloaded separately by executing
@verbatim
git clone https://github.com/Nek5000/Nek5000.git -b master
git clone https://github.com/adampep/KTH_Toolbox -b master
git clone https://github.com/adampep/KTH_Examples -b master
@endverbatim
or as a single framework by
@verbatim
git clone --recursive https://github.com/adampep/KTH_Framework
@endverbatim 

The second method is preferred as Nek5000 repository has neither development nor stable branches and all the 
development goes directly to master branch. As stable releases are marked by tags the user has to be careful 
to clone Nek5000 version compatible with current tool version. On the other hand the submodule within 
KTH_Framework points to the speciffic commit in Nek5000 repository forcing consistency between tools and 
Nek5000 versions. For the same reason user has to be careful using
@verbatim
git submodule update --remote Nek5000
@endverbatim
as it would load all the new commits. The proper way of upgrading KTH_Fremwork is running from the main 
framework directory
@verbatim
git fetch
git merge origin/master
git submodule update --recursive
@endverbatim 

@section documentation Documentation
To make this platform easy to use we pay attention to [Doxygen](http://www.stack.nl/~dimitri/doxygen/) 
based documentation of every tool. It has to provide detailed description of the tool itsef, 
the routine interfaces, runtime parameters and possible dependencies between modules. The general 
description of every tool is given in [FRAMEWORK.txt] (@ref toolbox), which is present in almost every 
directory. This documentation is available online as GitHub Pages (gh-pages bfranch) and can be generated 
locally by executing at the top level of the local copy of KTH_Framework repository:
@verbatim
mkdir html
doxygen ./docs/Doxyfile
rm doxygen.warning
@endverbatim
It requires doxygen 1.8.11 or newer and the dot tool from [Graphviz] (http://www.graphviz.org/). 
All files required by doxygen are located under ./docs/. It includes configuration file (Doxyfile), bibliography
(doxy.bib) and web pages contents (mainpage.dox). 

@todo Add possibility to generate documentation in KTH_Toolbox separately.




@page runtime_parameters_page Runtime parameters for KTH framework.

@section rparam_file Runtime parameter file.
An important issue for our framework is organised structure of runtime parameters that would allow for 
simple modiffication of parameter list without introducing conflicts between different code parts.
As old \a setup.rea file does not provide sufficent flexibility, all tool developers are obligated to use 
new  \a setup.par file instead, as it organises runtime parameters by sections and in addition to 20 user
parameters in \a [GENERAl] section allows to introduce user defined sections.
Every section starting with underscore is treated as user section and its consistency is not checked by Nek5000
core code. Following examples shows two native  Nek5000 sections and three user section correspondings to the modules 
[chkpoint] (@ref chkpoint), [tstepper] (@ref tstepper) and [arnoldi_arpack] (@ref arnoldi_arpack):
@code{.txt}
#
# nek parameter file
#
[GENERAL] 
#startFrom = restart.fld 
stopAt = numSteps #endTime
endTime = 1.0
numSteps = 500

[VELOCITY]
residualTol = 1e-12
residualProj = no
#density = 1

[_CHPOINT]
chkpInterval = 25
readchkpt = yes
chkpFnumber = 2
WallTime = 02:05
 
[_TIME_STEPPER]
mode = 1
steps =  40
maxCycles = 200
tol =  1.0E-06
ifuzawa = T

[_ARPACK]
arnkrylov = 100
arnegv = 10
arnistart = 1
arnistop = 2
@endcode

@section rparam_module Module's runtime parameters.
We utilize user defined sections in \a setup.par to set values of runtime parametes defined in different modules. 
To simplify interaction between different tools the [frame] (@ref frame) module provides dynamical database of 
all available in the framework runtime parameters. To achieve this we introduce module registration phase and split
if from module intialistation. The first step is initialisation of the framework itself by callilng [frame_start]
(@ref frame_start). Next all the tools have to register themselves, their runtime parameters (providing name, 
type, description and default values) and timers. At this point [frame_rparam] (@ref frame_rparam) can get values
of registerd runtime parametars stored \a setup.par and distribute them among processors. Finally all the modules can 
take back updated values of the runtime parameters and start module initialisation. Following example shows
the way to initialise framework na d checkpointing module in \a userchk:
@code{.f90}
      subroutine userchk
      include 'TSTEP'
      
      if (ISTEP.eq.0) then
!     start framework
         call frame_start
!     register modules
         call chkpt_register
!     get runtime parameters
         call frame_rparam
!     initialise modules
         call chkpt_init

      endif

!     save/load files for full-restart
      call chkpt_main

!     finalise framework
      if (ISTEP.ge.NSTEPS.or.LASTEP.eq.1) then
         call frame_end
      endif

      return
      end
@endcode

Each tool has to provide routines for registration and intialisation of the given module. [chkpt_register]
(@ref chkpt_register) and [chkpt_init] (@ref chkpt_init) are good example of them.

Dependencies between different modules can be expressed as a tree structure, which we would like to follow
in our databese. That is why each module during registration has to specify its parent, which can be its real
parent module (for submodules) or NEK5000 module (the first module registered by frame). In a similar way we 
specify parents for timers.

The list of all defined parameters, their dafault values and dependency between different modules are described in 
following pages:
- @subpage parameter_list_page
- @subpage parameter_required_page


@page parameter_list_page List of runtime parameters provided by modules.

@page parameter_required_page List of runtime parameters required by modules.

This page gives information about module dependencies.




@page compilation_page Setting up the case.

@todo Update this description after upgrading arnoldi.

To set up the case one has to check module dependency of the main tool described in FRAMEWORK.txt. An example shows
FRAMEWORK.txt file from [time stepper] (@ref tstepper) module:
@code{.txt}
#List of existing submodules
SUBMODULES arnildi_arpack \
           powerit

#List of conflicting submodules
EXCLUSIVE arnoldi_arpack \
          powerit

#Default submodules
DEFAULT arnoldi_arpack

#List of conflicting modules
CONFLICTS

#List of required modules
REQUIRED
         
#List of object files
OBJECT time_stepper.o

#List of include files
INCLUDE TIME_STEPPERD
@endcode

This module contains two conflicting submodules @ref arnoldi_arpack and @ref powerit. To setup specific case 
one has to check recursively dependency of all specified modules to get a complete list of required modules 
and exclude possible conflicts. In the case of spectra calulation with \a PARPACK library one checks FRAMEWORK.txt 
under \a tools/tstepper/arnoldi_arpack/ and finds that \a arnoldi_arpack depends on \a io/checkpoint/dummy and 
\a io/io_tools. On the other had \a io/checkpoint/dummy depends on \a io/checkpoint, so the final list of 
equired modules is:
- \a tools/tstepper,
- \a tools/tstepper/arnoldi_arpack/,
- \a io/checkpoint,
- \a io/checkpoint/dummy,
- \a io/io_tools.

Next one copies to the setup directory the source files listed in \a OBJECT and \a INCLUDE sections of 
FRAMEWORK.txt of all required modules, and adds content of \a OBJECT to USR variable in makenek. The last 
step before compilation is to concatenate makefile_usr.inc from requred modules' directories to generate
makefile_usr.inc in the setup directory.

@page developmnet_page Tool development workflow.

@todo Describe code development workflow.

@page interface_list_page List of interfaces provided by modules.

@page interface_required_page List of interfaces required by modules.

*/